import boto3
import json
import logging
import random
import re
import string
import sys

logger = logging.getLogger()
logger.setLevel(logging.INFO)

autoscaling = boto3.client("autoscaling")
ec2 = boto3.client("ec2")
route53 = boto3.client("route53")

HOSTNAME_TAG_NAME = "hostname_pattern"

LIFECYCLE_KEY = "LifecycleHookName"
ASG_KEY = "AutoScalingGroupName"
ZONE_ID = "${ZONE_ID}"
REVERSE_ZONE_ID = "${REVERSE_ZONE_ID}"

COLORS = [
    'almond', 'apricot', 'aquamarine', 'asparagus', 'banana', 'beige', 'bittersweet', 'blue',
    'blush', 'carmine', 'cerise', 'cerulean', 'copper', 'cornflower', 'dandelion', 'denim',
    'eggplant', 'eggshell', 'fern', 'goldenrod', 'green', 'inchworm', 'indigo', 'magenta',
    'mahogany', 'maize', 'mango', 'maroon', 'mauve', 'melon', 'mulberry', 'offwhite', 'orange',
    'orchid', 'peach', 'periwinkle', 'plum', 'razzmatazz', 'red', 'pink', 'scarlet', 'sepia',
    'shadow', 'shamrock', 'silver', 'tan', 'teal', 'thistle', 'tumbleweed', 'violet', 'wisteria',
    'yellow'
]

ANIMALS = [
    'alligator', 'alpaca', 'ant', 'antelope', 'ape', 'armadillo', 'baboon', 'badger', 'bat', 'bear',
    'bee', 'beetle', 'buffalo', 'butterfly', 'camel', 'caribou', 'cat', 'cattle', 'cheetah',
    'chinchilla', 'cicada', 'clam', 'cockroach', 'cod', 'coyote', 'crab', 'cricket', 'crocodile',
    'crow', 'deer', 'dinosaur', 'dog', 'dolphin', 'donkey', 'duck', 'eel', 'elephant', 'elk', 'emu',
    'ferret', 'fish', 'fly', 'fox', 'frog', 'gerbil', 'giraffe', 'goldendoodle', 'gnat', 'gnu',
    'goat', 'goldfish', 'gorilla', 'grackle', 'grasshopper', 'hamster', 'hare', 'hedgehog',
    'herring', 'hippo', 'hog', 'hornet', 'horse', 'hound', 'hyena', 'impala', 'insect', 'jackal',
    'jellyfish', 'kangaroo', 'koala', 'leopard', 'lion', 'lizard', 'llama', 'locust', 'louse',
    'mallard', 'magpie', 'mammoth', 'manatee', 'marten', 'mink', 'minnow', 'mole', 'monkey',
    'moose', 'mosquito', 'mouse', 'mule', 'muskrat', 'otter', 'ox', 'oyster', 'panda', 'pig',
    'penguin', 'platypus', 'porcupine', 'pug', 'puppy', 'rabbit', 'raccoon', 'rat', 'raven',
    'reindeer', 'rhinoceros', 'ria', 'salmon', 'sardine', 'scorpion', 'seal', 'serval', 'shark',
    'sheep', 'skunk', 'snail', 'snake', 'spider', 'squirrel', 'swan', 'swine', 'termite', 'tick',
    'tiger', 'toad', 'trout', 'turtle', 'wallaby', 'walrus', 'wasp', 'weasel', 'whale',
    'wildebeest', 'wolf', 'wombat', 'woodchuck', 'worm', 'yak', 'yellowjacket', 'zebra'
]

random_renderers = {
    "rand1": lambda: rand_string(1),
    "rand4": lambda: rand_string(4),
    "rand6": lambda: rand_string(6),
    "rand8": lambda: rand_string(8),
    "color": lambda: random.choice(COLORS),
    "animal": lambda: random.choice(ANIMALS),
}


def rand_string(length):
    letters = string.ascii_lowercase
    result_str = "".join(random.choice(letters) for i in range(length))
    return result_str


def generate_hostname(hostname):
    hostname_regex = "(?:{{)?(\w+)(-)?(?:}})?(-)?"
    hostname_components = re.findall(hostname_regex, hostname)
    hostname_gen = []
    for component in hostname_components:
        for value in component:
            if value in random_renderers:
                hostname_gen.append(random_renderers[value]())
            elif value != "":
                hostname_gen.append(value)
    print("".join(hostname_gen))


# Fetches private IP of an instance via EC2 API
def fetch_private_ip_from_ec2(instance_id):
    logger.info("Fetching private IP for instance-id: %s", instance_id)

    ec2_response = ec2.describe_instances(InstanceIds=[instance_id])
    ip_address = ec2_response["Reservations"][0]["Instances"][0]["NetworkInterfaces"][
        0
    ]["PrivateIpAddress"]

    logger.info("Found private IP for instance-id %s: %s", instance_id, ip_address)

    return ip_address


# Fetches private IP of an instance via route53 API
def fetch_private_ip_from_route53(hostname, ZONE_ID):
    logger.info("Fetching private IP for hostname: %s", hostname)

    ip_address = route53.list_resource_record_sets(
        HostedZoneId=ZONE_ID,
        StartRecordName=hostname,
        StartRecordType="A",
        MaxItems="1",
    )["ResourceRecordSets"][0]["ResourceRecords"][0]["Value"]

    logger.info("Found private IP for hostname %s: %s", hostname, ip_address)

    return ip_address


# Fetches relevant tags from ASG
# Returns tuple of hostname_pattern, ZONE_ID
def fetch_tag_metadata(asg_name):
    logger.info("Fetching tags for ASG: %s", asg_name)

    tag_value = autoscaling.describe_tags(
        Filters=[
            {"Name": "auto-scaling-group", "Values": [asg_name]},
            {"Name": "key", "Values": [HOSTNAME_TAG_NAME]}
        ],
        MaxRecords=1,
    )["Tags"][0]["Value"]

    logger.info("Found tags for ASG %s: %s", asg_name, tag_value)

    return tag_value


# Updates the name tag of an instance
def update_name_tag(instance_id, hostname):
    tag_name = hostname.split(".")[0]
    logger.info("Updating name tag for instance-id %s with: %s", instance_id, tag_name)
    ec2.create_tags(Resources=[instance_id], Tags=[{"Key": "Name", "Value": tag_name}])


# Updates a Route53 record
def update_record(ZONE_ID, ip, hostname, operation):
    logger.info(
        "Changing record with %s for %s -> %s in %s", operation, hostname, ip, ZONE_ID
    )
    route53.change_resource_record_sets(
        HostedZoneId=ZONE_ID,
        ChangeBatch={
            "Changes": [
                {
                    "Action": operation,
                    "ResourceRecordSet": {
                        "Name": hostname,
                        "Type": "A",
                        "TTL": 300,
                        "ResourceRecords": [{"Value": ip}],
                    },
                }
            ]
        },
    )


# Processes a scaling event
# Builds a hostname from tag metadata, fetches a private IP, and updates records accordingly
def process_message(message):
    logger.info("Processing %s event", message["LifecycleTransition"])

    if message["LifecycleTransition"] == "autoscaling:EC2_INSTANCE_LAUNCHING":
        operation = "UPSERT"
    elif (
        message["LifecycleTransition"] == "autoscaling:EC2_INSTANCE_TERMINATING"
        or message["LifecycleTransition"] == "autoscaling:EC2_INSTANCE_LAUNCH_ERROR"
    ):
        operation = "DELETE"
    else:
        logger.error(
            "Encountered unknown event type: %s", message["LifecycleTransition"]
        )

    asg_name = message["AutoScalingGroupName"]
    instance_id = message["EC2InstanceId"]

    hostname_pattern = fetch_tag_metadata(asg_name)
    hostname = generate_hostname(hostname_pattern)

    if operation == "UPSERT":
        private_ip = fetch_private_ip_from_ec2(instance_id)

        update_name_tag(instance_id, hostname)
    else:
        private_ip = fetch_private_ip_from_route53(hostname, ZONE_ID)

    update_record(ZONE_ID, private_ip, hostname, operation)


# Picks out the message from a SNS message and deserializes it
def process_record(record):
    process_message(json.loads(record["Sns"]["Message"]))


# Main handler where the SNS events end up to
# Events are bulked up, so process each Record individually
def lambda_handler(event, context):
    logger.info("Processing SNS event: " + json.dumps(event))

    for record in event["Records"]:
        process_record(record)

    # Finish the asg lifecycle operation by sending a continue result
    logger.info("Finishing ASG action")
    message = json.loads(record["Sns"]["Message"])
    if LIFECYCLE_KEY in message and ASG_KEY in message:
        response = autoscaling.complete_lifecycle_action(
            LifecycleHookName=message["LifecycleHookName"],
            AutoScalingGroupName=message["AutoScalingGroupName"],
            InstanceId=message["EC2InstanceId"],
            LifecycleActionToken=message["LifecycleActionToken"],
            LifecycleActionResult="CONTINUE",
        )
        logger.info("ASG action complete: %s", response)
    else:
        logger.error("No valid JSON message")


# if invoked manually, assume someone pipes in a event json
if __name__ == "__main__":
    logging.basicConfig()

    lambda_handler(json.load(sys.stdin), None)
